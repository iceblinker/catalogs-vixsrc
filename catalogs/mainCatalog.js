// Main catalog logic for vixsrc_movies and vixsrc_series
// Exports a function that takes (params, db, utils) and returns metas array

const path = require('path');
const fs = require('fs');

module.exports = async function mainCatalog({ type, id, extra, skip, TMDB_SERIES_GENRE_MAP, KEYWORD_CATALOGS, toMetaPreview, fullMeta, log, db }) {
    let genre = extra.genre || '';
    // Map special genre names to keyword catalog keys
    const specialGenreMap = {
        'Animal Horror': 'animal_horror',
        'Virus & Disease': 'virus_catalog',
        'Dystopia': 'dystopia_catalog',
        'Apocalypse': 'apocalypse_catalog',
        'Supernatural': 'supernatural_catalog'
    };
    let keywordGenreKey = null;
    if (genre && specialGenreMap[genre]) {
        keywordGenreKey = specialGenreMap[genre];
        genre = '';
    }
    const table = type === 'movie' ? 'movie_metadata' : 'tv_metadata';

    // 1. KEYWORD-BASED FILTER (main catalog)
    log(`[DEBUG] keywordGenreKey: ${keywordGenreKey}`);
    if (keywordGenreKey) {
        const cfg = KEYWORD_CATALOGS[keywordGenreKey];
        if (cfg && ((type === 'movie' && cfg.includeMovies) || (type === 'series' && cfg.includeTV))) {
            // Exclude genres: Documentary, Reality, Talk, Animation (case-insensitive, Italian and English)
            const excludedGenres = ['documentario', 'documentary', 'reality', 'talk', 'animazione', 'animation'];
            let where, params;
            if (keywordGenreKey === 'animal_horror') {
                // Require genre Horror (any language/variant) AND animal keywords
                const horrorVariants = ['horror'];
                where = 'rating >= ? AND (' + cfg.keywords.map(() => 'keywords LIKE ?').join(' OR ') + ') AND (' + horrorVariants.map(() => 'genres LIKE ?').join(' OR ') + ') AND (' + excludedGenres.map(() => 'genres NOT LIKE ?').join(' AND ') + ')';
                params = [cfg.minRating, ...cfg.keywords.map(k => `%${k}%`), ...horrorVariants.map(g => `%${g}%`), ...excludedGenres.map(g => `%${g}%`), skip];
            } else if (keywordGenreKey === 'virus_catalog') {
                // Exclude Famiglia, Commedia, Musica, Romance (romantico) in addition to the standard exclusions
                const extraExclusions = ['famiglia', 'commedia', 'musica', 'romance', 'romantico'];
                const allExclusions = excludedGenres.concat(extraExclusions);
                // Exclude specific disease keywords
                const excludedKeywords = ['alzheimers', 'parkinsons', 'aids', 'hiv'];
                where = 'rating >= ? AND (' + cfg.keywords.map(() => 'keywords LIKE ?').join(' OR ') + ') AND (' + allExclusions.map(() => 'genres NOT LIKE ?').join(' AND ') + ') AND (' + excludedKeywords.map(() => 'keywords NOT LIKE ?').join(' AND ') + ')';
                params = [cfg.minRating, ...cfg.keywords.map(k => `%${k}%`), ...allExclusions.map(g => `%${g}%`), ...excludedKeywords.map(k => `%${k}%`), skip];
            } else {
                where = 'rating >= ? AND (' + cfg.keywords.map(() => 'keywords LIKE ?').join(' OR ') + ') AND (' + excludedGenres.map(() => 'genres NOT LIKE ?').join(' AND ') + ')';
                params = [cfg.minRating, ...cfg.keywords.map(k => `%${k}%`), ...excludedGenres.map(g => `%${g}%`), skip];
            }
            const rows = db.prepare(`
                SELECT * FROM ${table}
                WHERE ${where}
                ORDER BY ${type === 'movie' ? 'release_date' : 'last_air_date'} DESC
                LIMIT 100 OFFSET ?
            `).all(...params);
            const metas = rows.map(r => toMetaPreview(fullMeta(r, type)));
            log(`[Catalog] SpecialGenre:${keywordGenreKey}  returned ${metas.length}`);
            return metas;
        }
    }

    // 2. NUOVI EPISODI (no sort change)
    log(`[DEBUG] genre: ${genre}, type: ${type}`);
    if (genre === 'Nuovi Episodi' && type === 'series') {
        // Use the cache file generated by the update script
        const cachePath = path.join(__dirname, '../cache-nuoviepisodi-series.json');
        if (!fs.existsSync(cachePath)) {
            log('[Catalog] NuoviEpisodi cache not found');
            return [];
        }
        let cache;
        try {
            cache = JSON.parse(fs.readFileSync(cachePath, 'utf8'));
        } catch (e) {
            log('[Catalog] NuoviEpisodi cache parse error:', e.message);
            return [];
        }
        const ids = Array.isArray(cache.ids) ? cache.ids : [];
        log(`[DEBUG] NuoviEpisodi cache loaded with ${ids.length} ids`);
        // Query for rows in tv_metadata
        const foundRows = ids.map(id => {
            const row = db.prepare('SELECT * FROM tv_metadata WHERE tmdb_id = ?').get(Number(id));
            return row;
        }).filter(r => !!r);
        log(`[DEBUG] NuoviEpisodi rows found in db: ${foundRows.length}`);
        const rows = foundRows;
        const metas = rows.slice(skip, skip + 100).map(r => toMetaPreview(fullMeta(r, 'series')));
        log(`[Catalog] NuoviEpisodi  returned ${metas.length}`);
        return metas;
    }

    // 3. NOVITA / TRENDING CACHE (no sort change)
    log(`[DEBUG] genre: ${genre}`);
    if (["NovitÃ ", "Trending"].includes(genre)) {
        const cacheFile = path.join(__dirname, `../cache-${genre.toLowerCase()}-${type}.json`);
        if (!fs.existsSync(cacheFile)) return [];
        const cached = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));
        const metas = (cached.metas || []).slice(skip, skip + 100).map(toMetaPreview);
        log(`[Catalog] ${genre} cache  returned ${metas.length}`);
        return metas;
    }

    // 4. GENERIC GENRE / SEARCH + DATE SORT
    log('[DEBUG] Entering generic genre/search block');
    let query = `SELECT * FROM ${table} WHERE 1=1`;
    const params = [];
    const excludedGenres = ['documentario', 'documentary', 'reality', 'talk', 'animazione', 'animation'];
    const strictExcludedGenres = ['documentario', 'documentary', 'reality', 'talk', 'animazione', 'animation', 'bambini', 'kids'];
    // Special handling: if main catalog, type movie, and genre filter is 'Cinema TV', map to only titles with genre name 'televisione film'
    if (genre === 'Cinema TV' && type === 'movie' && id === 'vixsrc_movies') {
        query += ` AND genres LIKE ?`;
        params.push('%televisione film%');
    } else if (genre && type === 'series' && Object.values(TMDB_SERIES_GENRE_MAP).includes(genre)) {
        const genreId = Object.keys(TMDB_SERIES_GENRE_MAP).find(id => TMDB_SERIES_GENRE_MAP[id] === genre);
        if (genreId) {
            query += ` AND (',' || genre_ids || ',') LIKE ?`;
            params.push(`%,${genreId},%`);
        }
        if (!strictExcludedGenres.map(g => g.toLowerCase()).includes(genre.toLowerCase())) {
            query += ' AND ' + strictExcludedGenres.map(() => 'genres NOT LIKE ?').join(' AND ');
            params.push(...strictExcludedGenres.map(g => `%${g}%`));
        }
    } else if (genre && type === 'series' && genre.toLowerCase() === 'documentario') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,99,%');
    } else if (genre && type === 'series' && genre.toLowerCase() === 'reality') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,10764,%');
    } else if (genre && type === 'series' && genre.toLowerCase() === 'soap') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,10766,%');
    } else if (genre && type === 'series' && genre.toLowerCase() === 'war & politics') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,10768,%');
    } else if (genre && type === 'series' && genre.toLowerCase() === 'talk') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,10767,%');
    } else if (genre && type === 'series' && genre.toLowerCase() === 'western') {
        query += ` AND (',' || genre_ids || ',') LIKE ?`;
        params.push('%,37,%');
    } else if (genre) {
        query += ` AND genres LIKE ?`;
        params.push(`%${genre}%`);
        if (!strictExcludedGenres.map(g => g.toLowerCase()).includes(genre.toLowerCase())) {
            query += ' AND ' + strictExcludedGenres.map(() => 'genres NOT LIKE ?').join(' AND ');
            params.push(...strictExcludedGenres.map(g => `%${g}%`));
        }
    } else {
        query += ' AND ' + strictExcludedGenres.map(() => 'genres NOT LIKE ?').join(' AND ');
        params.push(...strictExcludedGenres.map(g => `%${g}%`));
    }
    if (extra.search) { query += ` AND (title LIKE ? OR name LIKE ?)`; params.push(`%${extra.search}%`, `%${extra.search}%`); }
    query += ` ORDER BY ${type === 'movie' ? 'release_date' : 'last_air_date'} DESC LIMIT 100 OFFSET ?`;
    params.push(skip);
    const rows2 = db.prepare(query).all(...params);
    const metas2 = rows2.map(r => toMetaPreview(fullMeta(r, type)));
    log(`[Catalog] Generic  returned ${metas2.length}`);
    return metas2;
};
